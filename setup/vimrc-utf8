syntax on
filetype plugin on
filetype indent on

set guifont=RictyForPowerline-Regular:h14

" set {{{1
" タブページを常に表示
set number
set showtabline=2"
set title
set nocompatible
set noinsertmode
set ruler
set wildmode=list:longest
set wildmenu
set showmatch
set matchpairs+=<:>
set matchtime=3
set hidden
set nowrap
set list
set listchars=tab:\ \ ,trail:_,precedes:<,extends:>
set laststatus=2
set cmdheight=1
set showmode
set smartindent
set autoindent
set incsearch
set hlsearch
set wrapscan
set encoding=utf-8
set backspace=indent,start,eol
set fileformats=unix,dos,mac
set laststatus=2
set statusline=%<%f\ %m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}%=%l,%c%V%8p
set showcmd
set nrformats-=octal
set tags=./tags,../tags,~/tags
set viewdir=~/.backup/view
set backupdir=~/.backup/vim
set backup
set foldmethod=marker
set foldlevel=15
set completeopt+=longest
if exists('&ambiwidth')
	set ambiwidth=single
endif
let g:netrw_liststyle=1

" 自動文字コード判別 {{{1
set fileencoding=utf-8
set fileencodings=iso-2022-jp,utf-8,euc-jp,sjis
if has('autocmd')
	function! AU_ReCheck_FENC()
		if &fileencoding =~# 'iso-2022-jp' && search("[^\x01-\x7e]", 'n') == 0
			let &fileencoding=&encoding
		endif
	endfunction
	autocmd BufReadPost * call AU_ReCheck_FENC()
endif

" 自動バックアップ {{{1
if has( "autocmd" )
	autocmd BufWritePre * call UpdateBackupFile()
	function! UpdateBackupFile()
		let dir = strftime("~/.backup/vim/%Y/%m/%d", localtime())
		if !isdirectory(dir)
			let retval = system("mkdir -p ".dir)
			let retval = system("chown 500:500 ".dir)
		endif
		exe "set backupdir=".dir
		unlet dir

		let time = strftime("%H_%M_%S", localtime())
		exe "set backupext=.".time
	endfunction
endif

" mapping {{{1
map <C-E>n :tabnew<CR>
map <C-E>o :tabe
map <C-E>c :tabc
map <C-E><Right> :tabn<CR>
map <C-E><Left> :tabp<CR>

nmap n nzz
nmap N Nzz
nmap * *zz
nmap # #zz
nmap g* g*zz
nmap g# g#zz
nmap j gj
nmap k gk

nmap <ESC><ESC> :nohl<CR><ESC>

nmap \gc :cc<CR>
nmap \gp :cp<CR>
nmap \gP :cfirst<CR>
nmap \gn :cn<CR>
nmap \gN :clast<CR>

map \mm :set aw \| make \| set noaw<CR>
map \mn :set aw \| make clean \| make \| set noaw<CR>

map <C-T><C-T> :tabnew \| Explore<CR>
map <C-T><C-Y> :tabn<CR>
map <C-T><C-R> :tabp<CR>
map <C-T><C-G> :tabc<CR>
map! <C-T><C-T> <ESC>:tabnew \| Explore<CR>
map! <C-T><C-Y> <ESC>:tabn<CR>
map! <C-T><C-R> <ESC>:tabp<CR>
map! <C-T><C-G> <ESC>:tabc<CR>

map <C-E><C-E> :Explore<CR>
map! <C-E><C-E> <ESC>:Explore<CR>

map <C-P> <C-N>

if has( "clipboard" )
	vmap \d "+d
	vmap \D "+D
	vmap \y "+y
	vmap \Y "+Y
	vmap \p "+p
	vmap \P "+P
	nmap \d "+d
	nmap \D "+D
	nmap \y "+y
	nmap \Y "+Y
	nmap \p "+p
	nmap \P "+P
endif

" Color関係 {{{1
hi Pmenu ctermbg=4
hi PmenuSel ctermbg=1
hi PMenuSbar ctermbg=4
highlight Comment ctermfg=6

highlight ZenkakuSpace cterm=underline
match ZenkakuSpace /　/

" ファイル毎の設定 {{{1
if has( "autocmd" )
	autocmd FileType ruby set ts=2 sw=2 sts=2
	autocmd FileType actionscript :set dictionary=~/.vim/dict/actionscript3.dict
	autocmd FileType tex :set dictionary=~/.vim/dict/tex.dict
	autocmd FileType lecturememo :set dictionary=~/.vim/dict/tex.dict
	set complete+=k
endif

" errorformat関係 {{{1
if has( "autocmd" )
	autocmd filetype haskell set errorformat=
	autocmd filetype haskell set errorformat+=%f:%l:%c:\ %m
	autocmd filetype haskell set errorformat+=%f:%l:%c:
	autocmd filetype prolog set errorformat=
	autocmd filetype prolog set errorformat+=ERROR:\ %f:%l:%c:\ %m
endif
set errorformat+=%D%*\\a[%*\\d]:\ ディレクトリ\ `%f'\ に入りま<e3><81><99>
set errorformat+=%X%*\\a[%*\\d]:\ ディレクトリ\ `%f'\ から出ま<e3><81><99>

" いろいろ {{{1
if has( "autocmd" )
	autocmd BufReadPost *
				\ if line("'\"") > 0 && line("'\"") <= line("$") |
				\   exe "normal! g`\"" |
				\ endif
endif

if has( "autocmd" ) && exists( "+omnifunc" )
	autocmd Filetype *
				\   if &omnifunc == "" |
				\           setlocal omnifunc=syntaxcomplete#Complete |
				\   endif
endif

" plugin設定 {{{1
" autodate {{{2
let autodate_format="%Y/%m/%d %H:%M:%S"
" autocomplpop {{{2
let g:AutoComplPop_NotEnableAtStartup=1



""""""""""""""""""""""""""""
"プラグインのセットアップ
""""""""""""""""""""""""""""""
if has('vim_starting')
	set nocompatible
	set runtimepath+=~/.vim/bundle/neobundle.vim/
endif
call neobundle#begin(expand('~/.vim/bundle/'))
NeoBundle 'Shougo/neobundle.vim'
" NeoBundle 'Shougo/vimproc'
NeoBundle 'VimClojure'
NeoBundle 'Shougo/vimshell'
NeoBundle 'Shougo/unite.vim'
NeoBundle 'Shougo/neocomplcache'
NeoBundle 'Shougo/neosnippet'
NeoBundle 'Shougo/neosnippet-snippets'
NeoBundle 'jpalardy/vim-slime'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'scrooloose/nerdtree'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'tomtom/tcomment_vim'
NeoBundle 'vim-scripts/AnsiEsc.vim'
NeoBundle 'kana/vim-smartinput'
NeoBundle 'terryma/vim-multiple-cursors'
NeoBundle 'mhinz/vim-startify'
NeoBundle "osyo-manga/vim-over"
NeoBundle 'taglist.vim'
NeoBundle 'Source-Explorer-srcexpl.vim'
NeoBundle 'SrcExpl'
NeoBundle 'thinca/vim-ref'

NeoBundle 'Lokaltog/powerline', { 'rtp' : 'powerline/bindings/vim'}
NeoBundle 'Lokaltog/powerline-fontpatcher'
NeoBundle 'itchyny/lightline.vim'
call neobundle#end()

filetype plugin indent on

" If there are uninstalled bundles found on startup,
" this will conveniently prompt you to install them.
NeoBundleCheck
""""""""""""""""""""""""""""""





" 入力モードで開始する
let g:unite_enable_start_insert=1
" バッファ一覧
noremap <C-P> :Unite buffer<CR>
" ファイル一覧
noremap <C-N> :Unite -buffer-name=file file<CR>
" 最近使ったファイルの一覧
" noremap <C-Z> :Unite file_mru<CR>
 
" ウィンドウを分割して開く
au FileType unite nnoremap <silent> <buffer> <expr> <C-J> unite#do_action('split')
au FileType unite inoremap <silent> <buffer> <expr> <C-J> unite#do_action('split')
" ウィンドウを縦に分割して開く
au FileType unite nnoremap <silent> <buffer> <expr> <C-K> unite#do_action('vsplit')
au FileType unite inoremap <silent> <buffer> <expr> <C-K> unite#do_action('vsplit')
" ESCキーを2回押すと終了する
au FileType unite nnoremap <silent> <buffer> <ESC><ESC> :q<CR>
au FileType unite inoremap <silent> <buffer> <ESC><ESC> <ESC>:q<CR>
" 初期設定関数を起動する
au FileType unite call s:unite_my_settings()
    function! s:unite_my_settings()
    " Overwrite settings.
endfunction

" 様々なショートカット
call unite#custom#substitute('file', '\$\w\+', '\=eval(submatch(0))', 200)
call unite#custom#substitute('file', '^@@', '\=fnamemodify(expand("#"), ":p:h")."/"', 2)


" grep検索の実行後にQuickFix Listを表示する
autocmd QuickFixCmdPost *grep* cwindow
" ステータス行に現在のgitブランチを表示する
set statusline+=%{fugitive#statusline()}

" multiple cursor
" default mapping off
let g:multi_cursor_use_default_mapping=0
" Default mapping
"let g:multi_cursor_next_key='<C-n>'
" let g:multi_cursor_prev_key='<C-p>'
" let g:multi_cursor_skip_key='<C-x>'
"let g:multi_cursor_quit_key='<Esc>'
let g:multi_cursor_next_key='<C-@>'
let g:multi_cursor_quit_key='<Esc>'

" Tlist
let Tlist_Ctags_Cmd='/usr/local/bin/ctags'
" SrcExplToggle
let g:SrcExpl_updateTagsCmd = "/usr/local/bin/ctags --sort=foldcase -R ."
" NERDTree
"
if has("cscope")
	set csprg=/usr/local/bin/cscope
	set csto=0
	set cst
	set nocsverb
	" add any database in current directory
	if filereadable("cscope.out")
		cs add cscope.out
		" else add database pointed to by environment 
	elseif $CSCOPE_DB != ""
		cs add $CSCOPE_DB
	endif
	set csverb
	set cscopequickfix=s-,c-,d-,i-,t-,e-
endif


function! MakeTabLine()
	let titles = map(range(1, tabpagenr('$')), 's:tabpage_label(v:val)')
	let sep = ' | '  " タブ間の区切り
	let tabpages = join(titles, sep) . sep . '%#TabLineFill#%T'
	let info = ''  " 好きな情報を入れる
	return tabpages . '%=' . info  " タブリストを左に、情報を右に表示"
endfunction"

" 各タブページのカレントバッファ名+αを表示
function! s:tabpage_label(n)
	" t:title と言う変数があったらそれを使う
	let title = gettabvar(a:n, 'title')
	if title !=#''
		return title
	endif

	" タブページ内のバッファのリスト
	let bufnrs = tabpagebuflist(a:n)

	" カレントタブページかどうかでハイライトを切り替える
	let hi = a:n is tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'

	" バッファが複数あったらバッファ数を表示
	let no = len(bufnrs)
	if no is 1
		let no = ''
	endif
	
	" タブページ内に変更ありのバッファがあったら'+' を付ける
	let mod = len(filter(copy(bufnrs), 'getbufvar(v:val, "&modified")')) ? '+' : ''
	let sp = (no . mod) ==# '' ? '' : ' '  " 隙間空ける

	" カレントバッファ
	let curbufnr = bufnrs[tabpagewinnr(a:n) - 1]  " tabpagewinnr() は 1 origin
	let fname = pathshorten(bufname(curbufnr))

	let label = no . mod . sp .  fname

	return '%' . a:n . 'T' . hi . label . '%T%#TabLineFill#'
endfunction

set tabline=%!MakeTabLine()

" カラー設定
set t_Co=256
let g:lightline = {
     \ 'colorscheme': 'wombat',
     \ 'component': {
     \   'readonly': '%{&readonly?"x":""}',
     \ },
     \ 'separator': { 'left': "\u2b80", 'right': "\u2b82" },
     \ 'subseparator': { 'left': "\u2b81", 'right': "\u2b83" }
     \ }
